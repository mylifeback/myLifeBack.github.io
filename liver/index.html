<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - loaders - NRRD loader</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
  </head>

  <body>
    <div id="info">
      <a
        href="https://theNEUROSURGEONS.github.io"
        target="_blank"
        rel="noopener"
        >theNEUROSURGEONS</a
      >
      - 3D analysis for OT
    </div>
    <div id="inset"></div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@v0.164.1/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@v0.164.1/examples/jsm/"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";

      import Stats from "three/addons/libs/stats.module.js";

      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { TrackballControls } from "three/addons/controls/TrackballControls.js";
      import { NRRDLoader } from "three/addons/loaders/NRRDLoader.js";
      import { VTKLoader } from "three/addons/loaders/VTKLoader.js";

      let stats, camera, controls, scene, renderer;
      let sX, sY, sZ;
      const gui = new GUI();
      const loader = new NRRDLoader();
      const vtkloader = new VTKLoader();

      init();

      function init() {
        // Camera

        camera = new THREE.PerspectiveCamera(
          60,
          window.innerWidth / window.innerHeight,
          0.01,
          1e10
        );
        camera.position.z = 300;
        scene = new THREE.Scene();
        scene.add(camera);
        scene.background = new THREE.Color("beige");

        // light

        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x000000, 3);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(200, 200, 200);
        scene.add(dirLight);

        loader.load("I.nrrd", function (volume) {
          //box helper to see the extend of the volume
          const geometry = new THREE.BoxGeometry(
            volume.xLength,
            volume.yLength,
            volume.zLength
          );
          // const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
          // const cube = new THREE.Mesh(geometry, material);
          // cube.visible = false;
          // const box = new THREE.BoxHelper(cube);
          // scene.add(box);
          // box.applyMatrix4(volume.matrix);
          // scene.add(cube);

          //z plane
          const sliceZ = volume.extractSlice(
            "z",
            Math.floor(volume.RASDimensions[2] / 4)
          );
          sZ = sliceZ;
          // scene.add(sliceZ.mesh);
          // scene.remove(sZ.mesh);

          //y plane
          const sliceY = volume.extractSlice(
            "y",
            Math.floor(volume.RASDimensions[1] / 2)
          );
          sY = sliceY;
          // scene.add(sliceY.mesh);

          //x plane
          const sliceX = volume.extractSlice(
            "x",
            Math.floor(volume.RASDimensions[0] / 2)
          );
          sX = sliceX;
          // scene.add(sliceX.mesh);

          gui
            .add(sliceX, "index", 0, volume.RASDimensions[0], 1)
            .name("- Sagittal")
            .onChange(function () {
              sliceX.repaint.call(sliceX);
            });
          gui
            .add(sliceY, "index", 0, volume.RASDimensions[1], 1)
            .name("- Coronal")
            .onChange(function () {
              sliceY.repaint.call(sliceY);
            });
          gui
            .add(sliceZ, "index", 0, volume.RASDimensions[2], 1)
            .name("- Axial")
            .onChange(function () {
              sliceZ.repaint.call(sliceZ);
            });

          // gui
          //   .add(volume, "lowerThreshold", volume.min, volume.max, 1)
          //   .name("Lower Threshold")
          //   .onChange(function () {
          //     volume.repaintAllSlices();
          //   });
          // gui
          //   .add(volume, "upperThreshold", volume.min, volume.max, 1)
          //   .name("Upper Threshold")
          //   .onChange(function () {
          //     volume.repaintAllSlices();
          //   });
          // gui
          //   .add(volume, "windowLow", volume.min, volume.max, 1)
          //   .name("Window Low")
          //   .onChange(function () {
          //     volume.repaintAllSlices();
          //   });
          // gui
          //   .add(volume, "windowHigh", volume.min, volume.max, 1)
          //   .name("Window High")
          //   .onChange(function () {
          //     volume.repaintAllSlices();
          //   });
        });
      }

      // materials

      const lesionMaterial = new THREE.MeshPhongMaterial({
        wireframe: false,
        side: THREE.DoubleSide,
        color: 0x00ffff,
        transparent: true,
        opacity: 0.4,
      });

      const skinMaterial = new THREE.MeshPhongMaterial({
        wireframe: false,
        side: THREE.DoubleSide,
        color: 0x00ff00,
        transparent: true,
        opacity: 0.4,
      });

      const boneMaterial = new THREE.MeshPhongMaterial({
        wireframe: false,
        side: THREE.DoubleSide,
        color: 0x0000ff,
        transparent: true,
        opacity: 0.4,
      });

      // ?? lesion / skin / bone

      vtkloader.load("lesion.vtk", function (geometry) {
        geometry.computeVertexNormals();
        const mesh = new THREE.Mesh(geometry, lesionMaterial);
        scene.add(mesh);
        const lesion = {
          visible: true,
          opacity: 1,
        };

        gui
          .add(lesion, "visible")
          .name("Lesion Visible")
          .onChange(function () {
            mesh.visible = lesion.visible;
            renderer.render(scene, camera);
          });

        gui
          .add(lesion, "opacity", 0, 1, 0.1)
          .name("opacity - lesion")
          .onChange(function () {
            lesionMaterial.opacity = lesion.opacity;
            renderer.render(scene, camera);
          });
      });

      vtkloader.load("skin.vtk", function (geometry) {
        geometry.computeVertexNormals();
        const mesh = new THREE.Mesh(geometry, skinMaterial);
        scene.add(mesh);
        const skin = {
          visible: true,
          opacity: 0.2,
        };

        // gui
        //   .add(skin, "visible")
        //   .name("Skin Visible")
        //   .onChange(function () {
        //     mesh.visible = skin.visible;
        //     renderer.render(scene, camera);
        //   });

        gui
          .add(skin, "opacity", 0, 1, 0.1)
          .name("opacity - skin")
          .onChange(function () {
            skinMaterial.opacity = skin.opacity;
            renderer.render(scene, camera);
          });
      });

      vtkloader.load("bone.vtk", function (geometry) {
        geometry.computeVertexNormals();
        const mesh = new THREE.Mesh(geometry, boneMaterial);
        scene.add(mesh);
        const bone = {
          visible: true,
          opacity: 0.4,
        };

        // gui
        //   .add(bone, "visible")
        //   .name("Bone Visible")
        //   .onChange(function () {
        //     mesh.visible = bone.visible;
        //     renderer.render(scene, camera);
        //   });

        gui
          .add(bone, "opacity", 0, 1, 0.1)
          .name("opacity - bone")
          .onChange(function () {
            boneMaterial.opacity = bone.opacity;
            renderer.render(scene, camera);
          });
      });

      // ?? films visible
      {
        let films = { visible: false };

        gui
          .add(films, "visible")
          .name("Films Visible")
          .onChange(function () {
            let visible = films.visible;
            console.log(visible);
            console.log(sZ);
            if (!visible) {
              // scene.remove(sX.mesh);
              console.log("removed");
              scene.remove(sX.mesh);
              scene.remove(sY.mesh);
              scene.remove(sZ.mesh);
            } else {
              console.log("added");
              scene.add(sX.mesh);
              scene.add(sY.mesh);
              scene.add(sZ.mesh);
            }
            renderer.render(scene, camera);
          });
      }

      // renderer
      {
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        document.body.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.minDistance = 100;
        controls.maxDistance = 500;
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 5;
        controls.panSpeed = 2;
      }

      // stats = new Stats();
      // document.body.appendChild(stats.dom);

      window.addEventListener("resize", onWindowResize);

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        controls.handleResize();
      }

      function animate() {
        controls.update();

        renderer.render(scene, camera);

        // stats.update();
      }
    </script>
  </body>
</html>
